// Copyright 2021-present The Atlas Authors. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

package atlasaction

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"testing"

	"ariga.io/atlas/atlasexec"
	"github.com/rogpeppe/go-internal/diff"
	"github.com/rogpeppe/go-internal/testscript"
	"github.com/stretchr/testify/require"
)

func TestAzureDevOpsTask(t *testing.T) {
	wd, err := os.Getwd()
	require.NoError(t, err)
	testscript.Run(t, testscript.Params{
		Dir: filepath.Join("testdata", "azure"),
		Setup: func(e *testscript.Env) (err error) {
			commentsDir := filepath.Join(e.WorkDir, "comments")
			srv := httptest.NewServer(mockAzureDevOpsHandler(commentsDir, "test-token"))
			if err := os.Mkdir(commentsDir, os.ModePerm); err != nil {
				return err
			}
			e.Defer(srv.Close)
			e.Setenv("MOCK_ATLAS", filepath.Join(wd, "mock-atlas.sh"))
			e.Setenv("TF_BUILD", "True")
			e.Setenv("BUILD_REPOSITORY_PROVIDER", "GitHub")
			e.Setenv("BUILD_SOURCESDIRECTORY", e.WorkDir)
			// Set up mock Azure DevOps API URL
			e.Setenv("AZURE_DEVOPS_API_URL", srv.URL)
			return nil
		},
		Cmds: map[string]func(ts *testscript.TestScript, neg bool, args []string){
			"output": func(ts *testscript.TestScript, neg bool, args []string) {
				if len(args) == 0 {
					_, err := os.Stat(ts.MkAbs(".env"))
					if neg {
						if !os.IsNotExist(err) {
							ts.Fatalf("expected no output, but got some")
						}
						return
					}
					if err != nil {
						ts.Fatalf("expected output, but got none")
						return
					}
					return
				}
				cmpFiles(ts, neg, args[0], ".env")
			},
		},
	})
}

func TestAuthEndpoint(t *testing.T) {
	m := map[string]string{
		"ENDPOINT_AUTH_oauth": `{"scheme":"OAuth","parameters":{"AccessToken":"oauth-token"}}`,
		"ENDPOINT_AUTH_pat":   `{"scheme":"PersonalAccessToken","parameters":{"accessToken":"my-token"}}`,
		"ENDPOINT_AUTH_token": `{"scheme":"Token","parameters":{"AccessToken":"token"}}`,

		"ENDPOINT_AUTH_invalid-oauth": `{"scheme":"OAuth","parameters":{"foo":"bar"}}`,
		"ENDPOINT_AUTH_invalid-pat":   `{"scheme":"PersonalAccessToken","parameters":{"foo":"bar"}}`,
		"ENDPOINT_AUTH_invalid-token": `{"scheme":"Token","parameters":{"foo":"bar"}}`,
	}
	a := NewAzure(func(s string) string { return m[s] }, io.Discard)

	tok, err := a.getGHToken("oauth")
	require.NoError(t, err)
	require.Equal(t, "oauth-token", tok)

	tok, err = a.getGHToken("pat")
	require.NoError(t, err)
	require.Equal(t, "my-token", tok)

	tok, err = a.getGHToken("token")
	require.NoError(t, err)
	require.Equal(t, "token", tok)

	_, err = a.getGHToken("unknown")
	require.ErrorContains(t, err, "ENDPOINT_AUTH_unknown is not set")

	_, err = a.getGHToken("invalid-oauth")
	require.ErrorContains(t, err, "missing AccessToken in ENDPOINT_AUTH_invalid-oauth")
	_, err = a.getGHToken("invalid-pat")
	require.ErrorContains(t, err, "missing accessToken in ENDPOINT_AUTH_invalid-pat")
	_, err = a.getGHToken("invalid-token")
	require.ErrorContains(t, err, "missing AccessToken in ENDPOINT_AUTH_invalid-token")
}

func TestAzureDevOpsClient(t *testing.T) {
	// Mock server for Azure DevOps API
	server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch {
		case strings.Contains(r.URL.Path, "/pullrequests/") && !strings.Contains(r.URL.Path, "/threads"):
			// GET pull request
			response := map[string]interface{}{
				"pullRequestId": 123,
				"title":         "Test PR",
			}
			json.NewEncoder(w).Encode(response)
		case strings.Contains(r.URL.Path, "/threads") && r.Method == "GET":
			// GET comment threads
			response := map[string]interface{}{
				"value": []map[string]interface{}{
					{
						"id": 1,
						"comments": []map[string]interface{}{
							{
								"id":      101,
								"content": "Existing comment\n<!-- generated by ariga/atlas-action for test-id -->",
							},
						},
					},
				},
			}
			json.NewEncoder(w).Encode(response)
		case strings.Contains(r.URL.Path, "/threads") && r.Method == "POST":
			// POST create comment thread
			response := map[string]interface{}{
				"id": 2,
				"comments": []map[string]interface{}{
					{
						"id":      102,
						"content": "New comment content",
					},
				},
			}
			w.WriteHeader(http.StatusCreated)
			json.NewEncoder(w).Encode(response)
		case strings.Contains(r.URL.Path, "/comments/") && r.Method == "PATCH":
			// PATCH update comment
			response := map[string]interface{}{
				"id":      101,
				"content": "Updated comment content",
			}
			json.NewEncoder(w).Encode(response)
		}
	}))
	defer server.Close()

	t.Run("CommentLint", func(t *testing.T) {
		// Create client (we can't fully test HTTP calls without more setup)
		client, err := NewAzureDevOpsClient("testorg", "testproject", "testrepo", "test-token")
		require.NoError(t, err)
		require.NotNil(t, client)

		// Test that the client implements SCMClient interface
		var _ SCMClient = client
	})

	t.Run("CommentPlan", func(t *testing.T) {
		client, err := NewAzureDevOpsClient("testorg", "testproject", "testrepo", "test-token")
		require.NoError(t, err)
		require.NotNil(t, client)

		// Test that the client implements SCMClient interface
		var _ SCMClient = client
	})

	t.Run("CommentSchemaLint", func(t *testing.T) {
		client, err := NewAzureDevOpsClient("testorg", "testproject", "testrepo", "test-token")
		require.NoError(t, err)
		require.NotNil(t, client)

		// Test that the client implements SCMClient interface
		var _ SCMClient = client
	})
}

// mockAction implements the Action interface for testing
type mockAction struct {
	inputs map[string]string
}

func (m *mockAction) GetType() atlasexec.TriggerType   { return atlasexec.TriggerTypeAzureDevOps }
func (m *mockAction) Getenv(key string) string         { return "" }
func (m *mockAction) GetInput(name string) string      { return m.inputs[name] }
func (m *mockAction) SetOutput(name, value string)     {}
func (m *mockAction) Infof(msg string, args ...any)    {}
func (m *mockAction) Warningf(msg string, args ...any) {}
func (m *mockAction) Errorf(msg string, args ...any)   {}
func (m *mockAction) Fatalf(msg string, args ...any)   {}
func (m *mockAction) GetTriggerContext(context.Context) (*TriggerContext, error) {
	return nil, nil
}

var _ Action = (*mockAction)(nil)

func mockAzureDevOpsHandler(dir, token string) http.Handler {
	counter := 1
	m := http.NewServeMux()

	// GET pull request threads
	m.HandleFunc("GET /{org}/{project}/_apis/git/repositories/{repo}/pullrequests/{pr}/threads", func(w http.ResponseWriter, r *http.Request) {
		entries, err := os.ReadDir(dir)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		threads := make([]map[string]interface{}, 0)
		for _, e := range entries {
			b, err := os.ReadFile(filepath.Join(dir, e.Name()))
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			id, err := strconv.Atoi(e.Name())
			if err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
			thread := map[string]interface{}{
				"id": id,
				"comments": []map[string]interface{}{
					{
						"id":      id * 100,
						"content": string(b),
					},
				},
			}
			threads = append(threads, thread)
		}
		response := map[string]interface{}{
			"value": threads,
		}
		if err = json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})

	// POST create comment thread
	m.HandleFunc("POST /{org}/{project}/_apis/git/repositories/{repo}/pullrequests/{pr}/threads", func(w http.ResponseWriter, r *http.Request) {
		var body struct {
			Comments []struct {
				Content string `json:"content"`
			} `json:"comments"`
		}
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		if len(body.Comments) > 0 {
			// Add newline to match GitLab mock behavior and preserve newlines from upsertComment
			if err := os.WriteFile(filepath.Join(dir, strconv.Itoa(counter)), []byte(body.Comments[0].Content+"\n"), 0666); err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		}
		response := map[string]interface{}{
			"id": counter,
			"comments": []map[string]interface{}{
				{
					"id":      counter * 100,
					"content": body.Comments[0].Content,
				},
			},
		}
		counter++
		w.WriteHeader(http.StatusCreated)
		if err := json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})

	// PATCH update comment
	m.HandleFunc("PATCH /{org}/{project}/_apis/git/repositories/{repo}/pullrequests/{pr}/threads/{thread}/comments/{comment}", func(w http.ResponseWriter, r *http.Request) {
		threadID := r.PathValue("thread")
		if _, err := os.Stat(filepath.Join(dir, threadID)); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		var body struct {
			Content string `json:"content"`
		}
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
		if err := os.WriteFile(filepath.Join(dir, threadID), []byte(body.Content+"\n"), 0666); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		response := map[string]interface{}{
			"id":      r.PathValue("comment"),
			"content": body.Content,
		}
		if err := json.NewEncoder(w).Encode(response); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Check for authorization header
		if auth := r.Header.Get("Authorization"); auth != "Bearer "+token {
			http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
			return
		}
		m.ServeHTTP(w, r)
	})
}

func cmpFiles(ts *testscript.TestScript, neg bool, name1, name2 string) {
	text1 := ts.ReadFile(name1)
	data, err := os.ReadFile(ts.MkAbs(name2))
	ts.Check(err)
	eq := text1 == string(data)
	if neg {
		if eq {
			ts.Fatalf("%s and %s do not differ", name1, name2)
		}
		return // they differ, as expected
	}
	if eq {
		return // they are equal, as expected
	}
	unifiedDiff := diff.Diff(name1, []byte(text1), name2, data)
	ts.Logf("%s", unifiedDiff)
	ts.Fatalf("%s and %s differ", name1, name2)
}
